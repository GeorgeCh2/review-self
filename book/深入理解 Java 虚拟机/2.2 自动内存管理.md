### 运行时数据区域
#### 程序计数器
程序计数器（Program Counter Register）可以看作是当前线程所执行的字节码的**行号指示器**。  
在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选去下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  
Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现，在任何一个确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程中的指令。为了线程切换后能恢复到正确的的执行位置，每条线程都需要有一个独立的程序计数器（多个线程之间计数器互不影响），因此程序计数器内存区域是“线程私有”的内存。

### Java 虚拟机栈
Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。  
虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表**、**操作数栈**、**动态连接**、**方法出口**等信息。  
每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  
**局部变量表**存放了编译期可知的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**和 **returnAddress类型（指向了一条字节码指令的地址）**

### 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似，区别只是虚拟机栈为虚拟机所执行 Java 方法服务，而本地方法栈则是为虚拟机所使用的本地方法服务。

### Java 堆
对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中**最大的一块**。  
Java 堆事被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是**存放对象实例**。  
如果从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

### 方法区
方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的**类型信息**、**常量**、**静态变量**、**即时编译器编译后的代码缓存**等数据。

### 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 直接内存
在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的医用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。  
直接内存的分配不会受到 Java 堆大小的限制，但是会受到本机总内存大小以及处理器寻址空间的限制。