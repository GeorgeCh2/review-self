## 对于所有对象都通用的方法
### 8. 覆盖 equals 时请遵守通用约定
没有覆盖 equals 方法必要的情况：  
* 类的每个实例本质上都是唯一的
* 不关心类是否提供了“逻辑相等（logical equality）”的测试功能 - 调用者并不关心是否逻辑相等
* 超类已经覆盖了 equals，从超类继承过来的行为对于子类也是合法的
* 类是私有的或是包级私有的，可以确定它的 equals 方法永远不会被调用

euqals 等价关系的约定：
* 自反性 - `x.euqals(x) == true`
* 对称性 - `y.euqals(x) == true` 则 `x.equals(y) == true`
* 传递性 - `x.equals(y) == true` 且 `y.equals(z) == true`， 则 `x.equals(z) == true`  
    无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留传递性。  
    采用复合优于继承的原则。  
    可以在一个抽象（abstract）类的子类中增加新的值组件，而不会违反 equals 约定，因为不能直接创建超类的实例。
* 一致性 - 只要 euqals 的比较操作在对象中所用的信息没有被修改，多次调用 equals 都会返回一致的结果（equals 不能依赖于不可靠的资源）
* 非空性 - x.equals(null) 必须返回 false

实现高质量 equals 的方法：
* 使用 `==` 操作符检查 “参数是否为这个对象的引用”
* 使用 instanceof 操作符检查 “参数是否为正确的类型”
* 把参数转换成正确的类型
* 对于该类中的每个“关键（significant）域”，检查参数中的域是否域该对象中对应的域相匹配。
* 测试是否满足：对称性、传递性、一致性

```java
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }

    if (o instanceof MyClass) {
        MyClass oClass = (MyClass) o;
        return (field == oClass.field || field != null && field.euqals(oClass.field));
    }

    return false;
}
```