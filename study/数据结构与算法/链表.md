### 底层的存储结构
链表并不需要一块连续的内存空间，通过“指针”将一组零散的内存块串联起来使用。

### 常见的链表结构
#### 单链表
头节点记录链表的基地址，各结点同时存储着“后继指针 next”；尾结点的后继指针指向一个空地址 NULL
#### 循环链表
循环链表是一种特殊的单链表。与单链表唯一的区别是尾节点，循环链表的尾结点指针是指向链表的头节点
#### 双向链表
每个节点不止有一个后继指针，还有一个前驱指针 prev 指向前面的节点  
双向链表比单链表的原因：
* 删除节点中“值等于某个给定值”的节点：遍历查找的时间是主要的耗时点，两种链表的时间复杂度都是 O(n)
* 删除给定指针指向的节点：单链表为了修改删除结点对应前驱结点的 next 指针，需要找到前驱结点，导致时间复杂度为 O(n)

### 链表常用解题套路
#### 合并两个有序链表
虚拟头节点 + 循环比较两个链表（拉拉链）
#### 合并 k 个有序链表
快速得到 k 个节点中的最小节点（使用优先级队列数据结构）
#### 单链表中的倒数第 k 个节点
指针1 先走 k 步，指针2 从头节点开始和 指针1 同步向前走，指针1走到链表末尾，指针2 此时就处在倒数第 k 个节点
#### 单链表的中点
快慢指针 - slow 每次前进一步，fast 每次前进两步，当 fast 走到链表末尾时，slow 指向链表中点
#### 判断链表是否包含环
快慢指针 - slow 每次前进一步，fast 每次前进两步。如果 fast 遇到空指针，则没有环；如果 fast 和 slow 相遇，即 fast 超过了 slow 一圈，说明链表有环
计算环的起点 - 快慢指针相遇后，让其中任一个指针指向头节点，
#### 两个链表是否相交
指针 p1 遍历完 A 链表后开始遍历 B 链表，指针 p2 遍历完 B 链表后开始遍历 A 链表，可以让 p1 和 p2 同时到达相交点