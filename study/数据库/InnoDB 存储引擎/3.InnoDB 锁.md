## 锁
InnoDB 存储引擎中使用的是悲观锁，按照锁的粒度划分，可以分成行锁和表锁。
### 锁的种类
根据数据操作的形式，InnoDB 实现了两种标准的行级锁：共享锁（Shared Lock）和互斥锁（Exclusive Lock）
* 共享锁（读锁）：允许事务对一条行数据进行读取
* 互斥锁（写锁）：允许事务对一条行数据进行删除或更新
### 锁的粒度
InnoDB 支持多种粒度的锁，即行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种表级锁。
* 意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁
* 意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁  

意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示**是否有人请求锁定表中的某一行数据**。  
理解：如果没有意向锁，某一行添加了互斥锁的同时，另一个请求要对全表进行修改，就需要对所有的行是否被锁定进行扫描，这种情况下效率非常低；引入意向锁之后，当添加行锁前，会先为表添加意向互斥锁，这时如果有请求尝试对全表进行修改就不需要全表扫描判断是否被加锁，只需要等待意向互斥锁被释放就可以了。
### 锁的算法
三种锁的算法：
* Record Lock：单个行记录上的锁
* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
* Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

#### Record Lock
记录锁（Record Lock）是加到索引记录上的锁，如果 InnoDB 存储引擎表在建立的时候没有设置任何一个索引，那么 InnoDB 存储引擎会使用隐式的主键来进行锁定
#### Gap Lock
间隙锁（Gap Lock）是对索引记录中的一段连续区域的锁（当使用类似 `SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATA` 的 SQL 语句时，就会阻止其他事务向表中插入 `id = 15` 的记录，整个范围都被间隙锁锁定了）  
间隙锁是存储引擎对于性能和并发做出的权衡，并且只用于某些事务隔离级别。  
间隙锁唯一阻止的就是其它事务向锁定范围中添加新的记录。
#### Next-Key Lock
Next-Key 锁相比前两者稍微有一些复杂，它是记录锁和记录前的间隙锁的结合。  