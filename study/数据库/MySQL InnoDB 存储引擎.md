# MySQL 体系结构
数据库和实例：
* 数据库：物理操作文件系统或其他形式文件类型的集合
* 实例：MySQL 数据库由后台线程以及一个共享内存区组成  

从概念上讲，数据库是文件的集合，是依照某种数据模型阻止起来并存放于二级存储器中的数据集合；  
数据库实例是程序，是位于用户与操作系统之间的一层数据库管理软件，应用程序只有通过数据库实例才能和数据库打交道。 

MySQL 被设计为一个单进程多线程架构的数据库，MySQL 数据库实例在系统上的表现就是一个进程。

MySQL 的组成：
* 连接池组件
* 管理服务和工具组件
* SQL 接口组件
* 查询分析器组件
* 优化器组件
* 缓冲（Cache）组件
* 插件式存储引擎
* 物理文件

连接 MySQL 操作是一个连接进程和 MySQL 数据库实例进行通信。本质上是进城通信。

# InnoDB 存储引擎
## InnoDB 体系架构
![InnoDB 体系架构](https://github.com/GeorgeCh2/review-self/blob/master/img/InnoDB%202-1.png "InnoDB 存储引擎体系结构")
### 后台线程
InnoDB 存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。
#### Master Thread
Master Thread 是一个非常核心的后台线程，主要负责讲缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO 页的回收等。
#### IO Thread
IO Thread 的工作主要是负责 IO 请求的回调（call back）处理。  
包括 write、read、insert bufffer 和 log IO Thread
#### Purge Thread
事务被提交后，其所使用的 undolog 可能不再需要，因此需要 PurgeThread 来回收已经使用并分配的 undo 页。
#### Page Cleaner Thread
刷新脏页
### 内存
#### 缓冲池
InnoDB 存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。  
缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。
#### LRU List、Free List 和 Flush List
数据库中的缓冲池通过 LRU 算法来进行管理（通过 midpoint 改进该算法，解决因扫描全表导致热点数据被淘汰的问题）。
Flush List：脏页列表（页待刷新回磁盘）
#### 重做日志缓冲

## Checkpint 技术
Checkpoint 技术的目的：
* 缩短数据库的恢复时间（宕机后只恢复 Checkpoint 后的重做日志）
* 缓冲池不够用时，将脏页刷新到磁盘
* 重做日志不够用时，刷新脏页（将缓冲池中的页至少刷新到当前重做日志的位置）

Checkpoint 的种类：
* Sharp CheckPoint（数据库关闭时将所有脏页都刷新回磁盘）
* Fuzzy Checkpint
    * Master Thread Checkpoint（差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘）
    * FLUSH_LRU_LISR Checkpoint（LRU 列表没有足够的空闲页可供使用）
    * Async/Sync Flush Checkpoint（重做日志不可用，强制将一些页刷新回磁盘）
    * Dirty Page too much Checkpoint（脏页的数量太多，强制进行 Checkpoint）

## InnoDB 关键特性
* 插入缓冲（Insert Buffer）  
    对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个 Insert Buffer 对象中。  
    再以一定的频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge 操作。  
    使用 Insert Buffer 的条件
    * 索引时辅助索引
    * 索引不是唯一的
* 两次写（Double Write）  
  解决部分写失效的问题。增加页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。
* 自适应哈希索引（Adaptive Hash Index）
* 异步 IO（Ayync IO）  
  全部 IO 请求发送完毕后，等待所有 IO 操作的完成，不需要串行等待。  
  IO merge 操作。
* 刷新邻接页（Flush Neighbor Page）  
  当刷新一个脏页时，检测该页所在区的所有页，如果是脏页，则一起进行刷新。

## 数据的存储
在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）
### 如何存储表
MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中。
#### .frm 文件
无论在 MySQL 中选择哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义；.frm 文件的格式在不同的平台上都是相同的。
#### .ibd 文件
InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。  
当打开 innodb_file_per_table 选项时，.ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。
### 如何存储记录
#### 数据页结构
B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、next_reocrd 属性取出对应的记录

## 索引
索引优化是对查询性能优化的最有效手段
### 索引的数据结构
InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，数据库把整个页读入到内存中，并在内存中查找具体的数据行。
### 聚集索引和辅助索引
数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），它们之间最大区别就是，聚集索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的「书签」。
#### 聚集索引
InnoDB 存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放；聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。  
聚集索引与表的物理存储方式有着非常密切的关系，所有正常的表应该有且仅有一个聚集索引（绝大多数情况下都是主键），表中的所有行记录数据都是按照聚集索引的顺序存放的。  
当使用聚集索引对表中的数据进行检索时，可以直接获得聚集索引所对应的整条行记录数据所在的页，不需要进行第二次操作。
#### 辅助索引
数据库将所有非聚集索引都划分为辅助索引；辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的「书签」，在 InnoDB 中这个书签就是当前记录的主键。  
辅助索引的存在并不会影响聚集索引，辅助索引只用于加速数据的查找，一张表上往往有多个辅助索引以此来提升数据库的性能。  
使用辅助索引查找一条记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录。

## 锁
InnoDB 存储引擎中使用的是悲观锁，按照锁的粒度划分，可以分成行锁和表锁。
### 锁的种类
根据数据操作的形式，InnoDB 实现了两种标准的行级锁：共享锁（Shared Lock）和互斥锁（Exclusive Lock）
* 共享锁（读锁）：允许事务对一条行数据进行读取
* 互斥锁（写锁）：允许事务对一条行数据进行删除或更新
### 锁的粒度
InnoDB 支持多种粒度的锁，即行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种表级锁。
* 意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁
* 意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁  

意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示**是否有人请求锁定表中的某一行数据**。  
理解：如果没有意向锁，某一行添加了互斥锁的同时，另一个请求要对全表进行修改，就需要对所有的行是否被锁定进行扫描，这种情况下效率非常低；引入意向锁之后，当添加行锁前，会先为表添加意向互斥锁，这时如果有请求尝试对全表进行修改就不需要全表扫描判断是否被加锁，只需要等待意向互斥锁被释放就可以了。
### 锁的算法
三种锁的算法：Record Lock、Gap Lock 和 Next-Key Lock
#### Record Lock
记录锁（Record Lock）是加到索引记录上的锁
#### Gap Lock
间隙锁（Gap Lock）是对索引记录中的一段连续区域的锁（当使用类似 `SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATA` 的 SQL 语句时，就会阻止其他事务向表中插入 `id = 15` 的记录，整个范围都被间隙锁锁定了）  
间隙锁是存储引擎对于性能和并发做出的权衡，并且只用于某些事务隔离级别。  
间隙锁唯一阻止的就是其它事务向锁定范围中添加新的记录。
#### Next-Key Lock
Next-Key 锁相比前两者稍微有一些复杂，它是记录锁和记录前的间隙锁的结合。  

## 事务与隔离级别
事务遵循 ACID 四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）
### 几种隔离级别
隔离级别是提供给用户用于在性能和可靠性做出选择和权衡的配置项。
* READ UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（脏读 Dirty Read）
* READ COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁。允许新的记录插入到被锁定记录的附近，再多次使用查询语句时，可能得到不同的结果（不可重复读 Non-Repeatable Read）
* REPEATABLE READ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行（幻读 Phantom Read）
* SERIALIZABLE：InnoDB 隐式地将全部的查询语句加上共享锁，解决幻读的问题

MySQL 中默认的事务隔离级别时 REPEATABLE READ，通过 Next-Key 锁也能够在某种程度上解决幻读的问题。